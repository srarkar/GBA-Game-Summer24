#include "main.h"

#include <stdio.h>
#include <stdlib.h>
#include "snake_images/snake_apple.h"
#include "snake_images/forest.h"
#include "snake_images/game_win.h"
#include "snake_images/snake_frame1.h"
#include "snake_images/snake_frame2.h"
#include "snake_images/flower_vine.h"
#include "snake_images/vine_flipped.h"
#include "snake_images/lose_screen.h"
#include "snake_images/win_screen.h"
#include "snake_images/start_screen.h"
#include "gba.h"




/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.


static void setup(Game_t *g) {
  g->previousButtons = BUTTONS;
  g->currentButtons = BUTTONS;
  
  vBlankCounter = 0;
  g->state = START;
  g->timer = TIME_LIMIT;

  snake_t *sp = &g->snake;
  sp->length = SNAKE_LENGTH;
  sp->velX = SEGMENT_SIZE;
  sp->velY = 0;
  
  for (int i = 0; i < sp->length; i++) {
    if (i == 0) {
      sp->segs[i].x = WIDTH/2 - 10;
      sp->segs[i].y = HEIGHT/2;
      sp->segs[i].color = MAGENTA;
    } else {
      sp->segs[i].x = sp->segs[i - 1].x - SEGMENT_SIZE;
      sp->segs[i].y = sp->segs[i - 1].y;
      sp->segs[i].color = GREEN;
    }
  }

  g->eaten_counter = 0;
  
  for (int i = 0; i < NUM_APPLES; i++) { // initialize random apple locations
    apple_t *ap = g->apples + i;
    int rangeX = (WIDTH - 2 * BORDER - APPLE_SIZE)/NUM_APPLES;
    int minX = BORDER + i * rangeX;
    int maxX = minX + rangeX;
    ap->x = randint(minX, maxX);
    ap->y = randint(TIMER_HEIGHT + BORDER, HEIGHT - BORDER - APPLE_SIZE);
    ap->eaten = 0;
    ap->deleted = 0;

    if (i < NUM_APPLES - 1) {
      vine_t *vp = g->vines + 2*i;
      vp->x = ap->x + 2 * APPLE_SIZE;
      vp->y = TIMER_HEIGHT + BORDER;
      vp++;
      vp->x = ap->x + 2 * APPLE_SIZE;
      vp->y = HEIGHT - BORDER - VINE_HEIGHT;
    }
  }

  drawFullScreenImageDMA(start_screen);

  
  
}

/// START ///
static void start(Game_t *g) {

  if (KEY_JUST_PRESSED(BUTTON_START, g->currentButtons, g->previousButtons)) {
    g->state = PLAY;
    fillScreenDMA(BLACK); // play state background 

    // Dark Green Wall Borders
    drawRectDMA(TIMER_HEIGHT, 0, WIDTH, BORDER, FOREST_GREEN); // upper border
    drawRectDMA(TIMER_HEIGHT, 0, BORDER, HEIGHT - TIMER_HEIGHT, FOREST_GREEN); // left border
    drawRectDMA(TIMER_HEIGHT, WIDTH - BORDER, BORDER, HEIGHT - TIMER_HEIGHT, FOREST_GREEN); // right border
    drawRectDMA(HEIGHT - BORDER, 0, WIDTH, BORDER, FOREST_GREEN); // bottom border

    // Vines in Background
    //drawImageDMA(TIMER_HEIGHT + BORDER, 160, VINE_WIDTH, VINE_HEIGHT, vine); // top-right vine
    //drawImageDMA(HEIGHT - BORDER - VINE_HEIGHT, 80, VINE_WIDTH, VINE_HEIGHT, vine_flipped); // bottom-left vine

    // Drawing APPLES //
    for (int i = 0; i < NUM_APPLES; i++) {
      apple_t *ap = g->apples + i;
      drawImageDMA(ap->y, ap->x, APPLE_SIZE, APPLE_SIZE, snake_apple);
      if (i < NUM_APPLES - 1) {
        vine_t *vp = g->vines + 2*i;
        drawImageDMA(vp->y, vp->x, VINE_WIDTH, VINE_HEIGHT, flower_vine); // top-right vine
        vp++;
        drawImageDMA(vp->y, vp->x, VINE_WIDTH, VINE_HEIGHT, flower_vine); // bottom-left vine
      }
    }
  }
}

static int rectOverlap(int x1, int y1, int w1, int h1, int x2, int y2, int w2, int h2) {
  if (x1 + w1 < x2) {
    return 0;
  }
  if (x1 > x2 + w2) {
    return 0;
  }
  if (y1 + h1 < y2) {
    return 0;
  }
  if (y1 > y2 + h2) {
    return 0;
  }
  return 1;
}

static int fatalCollision(Game_t *g) { // check if snake has hit outer wall
  snakeSegment_t *head = &g->snake.segs[0];
  if ((head->x < BORDER) || (head->x + SEGMENT_SIZE > WIDTH - BORDER) ||
      (head->y < TIMER_HEIGHT + BORDER) || (head->y + SEGMENT_SIZE > HEIGHT - BORDER)) {
    return 1;
  }
  for (int i = 0; i < NUM_VINES; i++) {
    vine_t *vp = g->vines + i;
    if (rectOverlap(head->x, head->y, SEGMENT_SIZE, SEGMENT_SIZE, vp->x, vp->y, VINE_WIDTH, VINE_HEIGHT)) {
      return 1;
    }
  }
  return 0;
}

static void appleCollide(Game_t *g) { // collision detection for apple
  snake_t *sp = &g->snake;

  for (int i = 0; i < NUM_APPLES; i++) {
    apple_t *ap = g->apples + i;
    if (ap->eaten) {
      continue;
    }
    if (rectOverlap(sp->segs[0].x, sp->segs[0].y, SEGMENT_SIZE, SEGMENT_SIZE, 
                    ap->x, ap->y, APPLE_SIZE, APPLE_SIZE)) {
      ap->eaten = 1;
      ap->deleted = 0;
      g->eaten_counter++;
      break;
    }
  }
}




static void updateSnake(Game_t *g) {
  
  // Snake updated
  snake_t *sp = &g->snake;
  
  sp->oldTX = sp->segs[sp->length - 1].x;
  sp->oldTY = sp->segs[sp->length - 1].y;
  

  
  ///// change velX/velY;
  ///// Create collision check after; 

  if (sp->velX == 0) { // traveling vertical currently -- can only use left or right button
    if (KEY_JUST_PRESSED(BUTTON_LEFT, g->currentButtons, g->previousButtons)) {
      sp->velY = 0;
      sp->velX = -SEGMENT_SIZE;
    } else if (KEY_JUST_PRESSED(BUTTON_RIGHT, g->currentButtons, g->previousButtons)) {
      sp->velY = 0;
      sp->velX = SEGMENT_SIZE;
    }
  } else { // velY == 0 ; traveling horizontal currently -- only up or down button
    if (KEY_JUST_PRESSED(BUTTON_UP, g->currentButtons, g->previousButtons)) {
      sp->velX = 0;
      sp->velY = -SEGMENT_SIZE;
    } else if(KEY_JUST_PRESSED(BUTTON_DOWN, g->currentButtons, g->previousButtons)) {
      sp->velX = 0;
      sp->velY = SEGMENT_SIZE;
    }
  }


  // Update Body based on Prev velX/velY
  for (int i = sp->length - 1; i > 0; i--) {

    snakeSegment_t *curr = &sp->segs[i];
    snakeSegment_t *prev = &sp->segs[i - 1];
    curr->x = prev->x;
    curr->y = prev->y;
  }
  // Update Head Position
  sp->segs[0].x += sp->velX;
  sp->segs[0].y += sp->velY;
  
}

/// PLAY ///
static void play(Game_t *g) {

  int updateTimer = 0;
  snake_t *sp = &g->snake;
  
  if (g->timer < -1) { // if survived til time limit, WIN
    g->state = WIN;
    drawFullScreenImageDMA(win_screen);
    return;
  }
  

  // Timer updated every sec
  if (vBlankCounter % 60 == 0) {
     updateTimer = 1;
     sprintf(g->timerStr, "Survive for %02d more seconds!", g->timer);
     if (vBlankCounter > 0) { // pause for a second initially
      g->timer--;
     }  
  }

  updateSnake(g);
  
  if (fatalCollision(g)) { // if snake hits wall or poison ivy, YOU LOSE! :(
    g->state = LOSE;
    drawFullScreenImageDMA(lose_screen);
    return;
  }


  appleCollide(g);
  if (g->eaten_counter >= NUM_APPLES) {
    g->state = WIN;
    drawFullScreenImageDMA(win_screen);
    return;
  }

  waitForVBlank();

  //// UNDRAW BELOW ////
  

  //// DRAWING BELOW ////
  
  // Drawing TIMER //
  if (updateTimer) {
    drawRectDMA(10, 93, 11, 8, BLACK);
    drawString(10, 20, g->timerStr, WHITE);
  }

  // erase eaten apples with loop
  for (int i = 0; i < NUM_APPLES; i++) {
    apple_t *ap = g->apples + i;
    if (ap->eaten && !ap->deleted) { // apple consumed and not yet deleted
      drawRectDMA(ap->y, ap->x, APPLE_SIZE, APPLE_SIZE, BLACK);
      ap->deleted = 1; // mark apple as deleted
    }
  }


  // Drawing SNAKE //
  drawRectDMA(sp->oldTY, sp->oldTX, SEGMENT_SIZE, SEGMENT_SIZE, BLACK); // erase tail
  for (int i = 0; i < sp->length; i++) { // redraw each snakeSegment with updated vals
    drawRectDMA(sp->segs[i].y, sp->segs[i].x, SEGMENT_SIZE, SEGMENT_SIZE, sp->segs[i].color);
  } 

  


}

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  Game_t game;

  // Load initial application state
  setup(&game);

  while (1) {
    game.currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    if (KEY_JUST_PRESSED(BUTTON_SELECT, game.currentButtons, game.previousButtons)) {
         setup(&game);
    }

    switch (game.state) {
      case START:
        start(&game);
        break;

      case PLAY:
        play(&game);
        break;
      case WIN:

        break;
      case LOSE:

        break;
    }

    game.previousButtons = game.currentButtons; // Store the current state of the buttons
  }

  return 0;
}

